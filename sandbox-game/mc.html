<!DOCTYPE html>
<html>
<head>
<title>簡化版 3D 沙盒</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const renderer = canvas.getContext('webgl');

  if (!renderer) {
    console.error('您的瀏覽器不支持 WebGL');
  } else {
    // 設置畫布大小
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    renderer.viewport(0, 0, canvas.width, canvas.height);

    // 簡單的立方體頂點數據 (每個面兩個三角形)
    const vertices = [
      // 前面
      -0.5, -0.5,  0.5,   0.5, -0.5,  0.5,   0.5,  0.5,  0.5,
      -0.5, -0.5,  0.5,   0.5,  0.5,  0.5,  -0.5,  0.5,  0.5,

      // 後面
      -0.5, -0.5, -0.5,  -0.5,  0.5, -0.5,   0.5,  0.5, -0.5,
      -0.5, -0.5, -0.5,   0.5,  0.5, -0.5,   0.5, -0.5, -0.5,

      // 上面
      -0.5,  0.5, -0.5,  -0.5,  0.5,  0.5,   0.5,  0.5,  0.5,
      -0.5,  0.5, -0.5,   0.5,  0.5,  0.5,   0.5,  0.5, -0.5,

      // 下面
      -0.5, -0.5, -0.5,   0.5, -0.5, -0.5,   0.5, -0.5,  0.5,
      -0.5, -0.5, -0.5,   0.5, -0.5,  0.5,  -0.5, -0.5,  0.5,

      // 右面
       0.5, -0.5,  0.5,   0.5, -0.5, -0.5,   0.5,  0.5, -0.5,
       0.5, -0.5,  0.5,   0.5,  0.5, -0.5,   0.5,  0.5,  0.5,

      // 左面
      -0.5, -0.5,  0.5,  -0.5,  0.5,  0.5,  -0.5,  0.5, -0.5,
      -0.5, -0.5,  0.5,  -0.5,  0.5, -0.5,  -0.5, -0.5, -0.5,
    ];

    // 創建緩衝區並綁定頂點數據
    const vertexBuffer = renderer.createBuffer();
    renderer.bindBuffer(renderer.ARRAY_BUFFER, vertexBuffer);
    renderer.bufferData(renderer.ARRAY_BUFFER, new Float32Array(vertices), renderer.STATIC_DRAW);

    // 簡單的頂點著色器
    const vertexShaderSource = `
      attribute vec3 aVertexPosition;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
      }
    `;

    // 簡單的片段著色器
    const fragmentShaderSource = `
      void main() {
        gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0); // 灰色
      }
    `;

    // 創建和編譯著色器
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(renderer, renderer.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(renderer, renderer.FRAGMENT_SHADER, fragmentShaderSource);

    // 創建和鏈接程序
    const shaderProgram = renderer.createProgram();
    renderer.attachShader(shaderProgram, vertexShader);
    renderer.attachShader(shaderProgram, fragmentShader);
    renderer.linkProgram(shaderProgram);

    if (!renderer.getProgramParameter(shaderProgram, renderer.LINK_STATUS)) {
      console.error('Unable to initialize the shader program: ' + renderer.getProgramInfoLog(shaderProgram));
    }

    renderer.useProgram(shaderProgram);

    // 獲取屬性和 uniform 的位置
    const positionAttribute = renderer.getAttribLocation(shaderProgram, 'aVertexPosition');
    const modelViewMatrixUniform = renderer.getUniformLocation(shaderProgram, 'uModelViewMatrix');
    const projectionMatrixUniform = renderer.getUniformLocation(shaderProgram, 'uProjectionMatrix');

    // 啟用頂點屬性
    renderer.enableVertexAttribArray(positionAttribute);
    renderer.vertexAttribPointer(positionAttribute, 3, renderer.FLOAT, false, 0, 0);

    // 創建模型視圖和投影矩陣 (非常簡化)
    const modelViewMatrix = mat4.create();
    const projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -5.0]);

    // 渲染循環
    function render() {
      renderer.clearColor(0.0, 0.0, 0.0, 1.0);
      renderer.clearDepth(1.0);
      renderer.enable(renderer.DEPTH_TEST);
      renderer.depthFunc(renderer.LEQUAL);

      renderer.clear(renderer.COLOR_BUFFER_BIT | renderer.DEPTH_BUFFER_BIT);

      renderer.uniformMatrix4fv(modelViewMatrixUniform, false, modelViewMatrix);
      renderer.uniformMatrix4fv(projectionMatrixUniform, false, projectionMatrix);

      renderer.drawArrays(renderer.TRIANGLES, 0, vertices.length / 3);

      requestAnimationFrame(render);
    }

    render();
  }
</script>

</body>
</html>
