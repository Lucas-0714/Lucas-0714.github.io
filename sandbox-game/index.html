<!DOCTYPE html>
<html>
<head>
<title>行動裝置版互動式 3D 立方體 (不嵌入 gl-matrix)</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: sans-serif; }
  canvas { display: block; border: 1px solid #333; }
  #instructions { margin-top: 20px; font-size: 0.9em; color: #555; }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="instructions">在畫布上左右滑動以旋轉立方體</div>

<script src="gl-matrix-min.js"></script>
<script>
  const canvas = document.getElementById('gameCanvas');
  const renderer = canvas.getContext('webgl');

  if (!renderer) {
    alert('您的瀏覽器不支持 WebGL');
  } else {
    // 設置畫布大小
    canvas.width = window.innerWidth * 0.8;
    canvas.height = window.innerHeight * 0.8;
    renderer.viewport(0, 0, canvas.width, canvas.height);

    // 立方體頂點數據 (包含顏色)
    const vertices = [
      // 前面 (紅)
      -0.5, -0.5,  0.5,   1.0, 0.0, 0.0,
       0.5, -0.5,  0.5,   1.0, 0.0, 0.0,
       0.5,  0.5,  0.5,   1.0, 0.0, 0.0,
      -0.5, -0.5,  0.5,   1.0, 0.0, 0.0,
       0.5,  0.5,  0.5,   1.0, 0.0, 0.0,
      -0.5,  0.5,  0.5,   1.0, 0.0, 0.0,

      // 後面 (藍)
      -0.5, -0.5, -0.5,   0.0, 0.0, 1.0,
      -0.5,  0.5, -0.5,   0.0, 0.0, 1.0,
       0.5,  0.5, -0.5,   0.0, 0.0, 1.0,
      -0.5, -0.5, -0.5,   0.0, 0.0, 1.0,
       0.5,  0.5, -0.5,   0.0, 0.0, 1.0,
       0.5, -0.5, -0.5,   0.0, 0.0, 1.0,

      // 上面 (綠)
      -0.5,  0.5, -0.5,   0.0, 1.0, 0.0,
      -0.5,  0.5,  0.5,   0.0, 1.0, 0.0,
       0.5,  0.5,  0.5,   0.0, 1.0, 0.0,
      -0.5,  0.5, -0.5,   0.0, 1.0, 0.0,
       0.5,  0.5,  0.5,   0.0, 1.0, 0.0,
       0.5,  0.5, -0.5,   0.0, 1.0, 0.0,

      // 下面 (黃)
      -0.5, -0.5, -0.5,   1.0, 1.0, 0.0,
       0.5, -0.5, -0.5,   1.0, 1.0, 0.0,
       0.5, -0.5,  0.5,   1.0, 1.0, 0.0,
      -0.5, -0.5, -0.5,   1.0, 1.0, 0.0,
       0.5, -0.5,  0.5,   1.0, 1.0, 0.0,
      -0.5, -0.5,  0.5,   1.0, 1.0, 0.0,

      // 右面 (紫)
       0.5, -0.5,  0.5,   1.0, 0.0, 1.0,
       0.5, -0.5, -0.5,   1.0, 0.0, 1.0,
       0.5,  0.5, -0.5,   1.0, 0.0, 1.0,
       0.5, -0.5,  0.5,   1.0, 0.0, 1.0,
       0.5,  0.5, -0.5,   1.0, 0.0, 1.0,
       0.5,  0.5,  0.5,   1.0, 0.0, 1.0,

      // 左面 (青)
      -0.5, -0.5,  0.5,   0.0, 1.0, 1.0,
      -0.5,  0.5,  0.5,   0.0, 1.0, 1.0,
      -0.5,  0.5, -0.5,   0.0, 1.0, 1.0,
      -0.5, -0.5,  0.5,   0.0, 1.0, 1.0,
      -0.5,  0.5, -0.5,   0.0, 1.0, 1.0,
      -0.5, -0.5, -0.5,   0.0, 1.0, 1.0,
    ];

    // 創建緩衝區並綁定頂點數據
    const vertexBuffer = renderer.createBuffer();
    renderer.bindBuffer(renderer.ARRAY_BUFFER, vertexBuffer);
    renderer.bufferData(renderer.ARRAY_BUFFER, new Float32Array(vertices), renderer.STATIC_DRAW);

    // 頂點著色器
    const vertexShaderSource = `
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec3 vColor;
      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    `;

    // 片段著色器
    const fragmentShaderSource = `
      precision mediump float;
      varying vec3 vColor;
      void main() {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    // 創建和編譯著色器
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(renderer, renderer.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(renderer, renderer.FRAGMENT_SHADER, fragmentShaderSource);

    // 創建和鏈接程序
    const shaderProgram = renderer.createProgram();
    renderer.attachShader(shaderProgram, vertexShader);
    renderer.attachShader(shaderProgram, fragmentShader);
    renderer.linkProgram(shaderProgram);

    if (!renderer.getProgramParameter(shaderProgram, renderer.LINK_STATUS)) {
      console.error('Unable to initialize the shader program: ' + renderer.getProgramInfoLog(shaderProgram));
    }

    renderer.useProgram(shaderProgram);

    // 獲取屬性和 uniform 的位置
    const positionAttribute = renderer.getAttribLocation(shaderProgram, 'aVertexPosition');
    const colorAttribute = renderer.getAttribLocation(shaderProgram, 'aVertexColor');
    const modelViewMatrixUniform = renderer.getUniformLocation(shaderProgram, 'uModelViewMatrix');
    const projectionMatrixUniform = renderer.getUniformLocation(shaderProgram, 'uProjectionMatrix');

    // 啟用並配置頂點屬性
    renderer.enableVertexAttribArray(positionAttribute);
    renderer.vertexAttribPointer(positionAttribute, 3, renderer.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

    renderer.enableVertexAttribArray(colorAttribute);
    renderer.vertexAttribPointer(colorAttribute, 3, renderer.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

    // 創建模型視圖和投影矩陣
    const modelViewMatrix = mat4.create();
    const projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -5.0]);

    // 旋轉角度 (用於互動)
    let rotationAngle = 0;
    let startX = null;

    // 觸摸開始事件
    canvas.addEventListener('touchstart', (event) => {
      startX = event.touches[0].clientX;
    });

    // 觸摸移動事件
    canvas.addEventListener('touchmove', (event) => {
      if (startX !== null) {
        const currentX = event.touches[0].clientX;
        const deltaX = currentX - startX;
        rotationAngle += deltaX * 0.01; // 調整滑動靈敏度
        startX = currentX;
      }
    });

    // 觸摸結束事件
    canvas.addEventListener('touchend', () => {
      startX = null;
    });

    // 渲染循環
    function render() {
      renderer.clearColor(0.0, 0.0, 0.0, 1.0);
      renderer.clearDepth(1.0);
      renderer.enable(renderer.DEPTH_TEST);
      renderer.depthFunc(renderer.LEQUAL);

      renderer.clear(renderer.COLOR_BUFFER_BIT | renderer.DEPTH_BUFFER_BIT);

      const rotatedModelViewMatrix = mat4.clone(modelViewMatrix);
      mat4.rotateY(rotatedModelViewMatrix, rotatedModelViewMatrix, rotationAngle);

      renderer.uniformMatrix4fv(modelViewMatrixUniform, false, rotatedModelViewMatrix);
      renderer.uniformMatrix4fv(projectionMatrixUniform, false, projectionMatrix);

      renderer.drawArrays(renderer.TRIANGLES, 0, vertices.length / 3);

      requestAnimationFrame(render);
    }

    render();
  }
</script>

</body>
</html>
